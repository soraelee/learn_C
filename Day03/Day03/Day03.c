#include <stdio.h>

/*--------상수-------
- 항상 같은 수, 변경할 수 없는 데이터
- 리터럴(문자의, 문자 그대로의) 상수 : 사용자가 작성하는 문자 그대로를 의미
- 심볼릭 상수 : 이름을 가지고 있는 상수
- 심볼릭 상수 선언 원형 : 자료형 상수형; 이때, 자료형의 앞이나 뒤애 const 키워드를 추가해준다.
- 심볼릭 상수를 선언할 때는 반드시 초기화를 같이 진행해줘야 한다. 
  그렇지 않으면 이후에 값을 할당 하는데 어려움이	발생한다. (변경되면 안되는 데이터의 경우 상수로 선언)
*/

/*-------형 변환--------
C언어에서 연산이 진행될 때 모든 데이터가 같은 자료형으로 변환 후 연산이 진행되는 과정
- 자동 형 변환: C컴파일러가 자동으로 진행해주는 형 변환
  char -> short -> int(4byte) -> long -> float(4byte) -> double  순서로 진행
  정수와 실수가 연산이 진행될 때, 데이터의 손실이 적은 실수형으로 형 변환이 진행된다. 
- 강제 형 변환 : 사용자가 캐스트 연산자를 사용해 강제적으로 수행하는 형 변환
	강제 형 변환을 진행할 때는 변환하고 싶은 데이터 앞에 (변환할 자료형)을 작성해주면 된다.*/

/*----- 산술 연산자 -----
  + : 왼쪽의 피연산자에서 오른쪽의 피연산자를 더함
  - : 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌
  * : 왼쪽의 피연산자에서 오른쪽의 피연산자를 곱함
  / : 왼쪽의 피연산자를 오른쪽의 피연산자로 나눔 (이 때 int / int = double이 될 수 없음) => 몫을 구하는 과정
  % : 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 나머지를 반환*/

/* ----- 대입 연산자 -----
- = : 왼쪽의 피연산자에 오른쪽의 피연산자를 대입함*/

/* ----- 복합 대입 연산자 -----
- += : 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결과값을 왼쪽의 피연산자에 대입
- -= : 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결과값을 왼쪽의 피연산자에 대입
- *= : 왼쪽의 피연산자에서 오른쪽의 피연산자를 곱한 후, 그 결과값을 왼쪽의 피연산자에 대입
- /= : 왼쪽의 피연산자에서 오른쪽의 피연산자를 나눈 후, 그 결과값을 왼쪽의 피연산자에 대입
- %= : 왼쪽의 피연산자에서 오른쪽의 피연산자를 나눈 후, 그 나머지을 왼쪽의 피연산자에 대입*/

/* ----- 증감 연산자 ------
- 다른 연산자들과는 다르게 피연산자가 한 개 이다
- ++num(전위 증가 연산자 : 피연산자보다 앞에 있음) : 피연산자의 값을 1 증가시킨 후, 연산을 진행
- num++(후위 증가 연산자) : 연산을 먼저 진행하고 나서 그 뒤에 피연산자의 값을 1 증가
- --num(전위 감소 연산자) : 피연산자의 값을 1 감소시킨 후 연산을 진행
- num--(후위 감소 연산자) : 연산을 먼저 진행하고 나서 그 뒤에 피연산자의 값을 1 감소*/

/* ------ 비교 연산자 -----
- 연산의 결과가 참일 경우 1, 거짓일 경우는 0을 반환
- == : 왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 1을 반환
- != : 왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 1을 반환
- > : 왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 1을 반환
- >= : 왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 1을 반환
- < : 왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 1을 반환
- <= : 왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 1을 반환*/

/*------ 논리 연산자 ------
- &&(논리 AND 연산) : 논리식이 모두 참이면 1을 반환, 둘 중 하나라도 거짓이면 0을 반환
	- 논리 And 연산의 경우 왼쪽의 논리식이 거짓일 경우 오른쪽의 논리식은 진행하지 않는다. 
	거짓 && 거짓 = 0
	참 && 거짓 = 0
	거짓 && 참 = 0
	참 && 참 = 0

- ||(논리 OR 연산) : 논리식이 둘 중 하나라도 참이면 1을 반환
	- 논리 OR 연산의 경우 왼쪽의 논리식이 참일 경우 오른쪽의 논리식은 진행하지 않는다.
	거짓 || 거짓 = 0
	참 || 거짓 = 1
	거짓 || 참 = 1
	참 || 참 = 1

- !(논리 NOT 연산) : 참이면 거짓, 거짓을 참으로 반전]
	- 논리 NOT 연산의 경우는 피연산자가 한개만 존재한다. 
	
	
*/

int main()
{
	/* --- 리터럴 상수---
	printf("%s", "Abcd"); //Abcd ==리터럴 상수
	printf("%d", 5132); //5132 ==리터럴 상수
	*/
	
	/* // ---심볼릭 상수---
	int const con; //심볼릭 상수 선언
	const int con = 5; // 심볼릭 상수 선언 // 변수 초기화 방식 -- 값 할당과 구분할 필요가 있음

	printf("con의 값 : %d\n", con);
	*/

	/*// --- 형 변환 ---
	printf("연산 결과: %d\n", 3 + 5.5); // 3은 int형, 5.5는 double -- 3이 실수 형태로 변환 -- %d 형이라 출력이 되지 않을 것
	
	printf("연산 결과: %d\n", 3 + (int)5.5); //강제 형변환
	*/

	/*
	//Q1) 다음 변수에 저장된 값을 예상해보세요 -- num1, num2, num3
	
	int num1, num2, num3;

	num1 = 9 + 8 / 2 * 4;
	num2 = 8 - 12 * (2 + 2) / 8 % 2; 
	num3 = 1 % 3 * (1 + 3) * (12 / 6) % 10;

	printf("%d, %d, %d\n", num1, num2, num3);
	*/

	/*
	// 복합 대입 연산자
	int num = 7;
	
	num += 5; ///  == num = num + 5;
	printf("num의 값 : %d\n", num);
	*/

	/*
	// 전위 / 후위 증가 연산자
	int n1 = 8, n2 = 4, n3;
	n3 = n1++ + ++n2;

	printf("n3의 값 : %d\n", n3);
	*/

	/*
	// 증감 연산자 문제
	//Q1) 다음 변수에 저장된 값을 예상하기

	int a = 5, b = 6, c = 10, d;
	d = ++a * b--; //35
	printf("%d %d %d\n", a, b, d);	//6 5 35
	
	d = a++ + ++c - b--; //10
	printf("%d %d %d %d\n", a, b , c, d); //7 4 11 12
	*/

	/*
	// 비교연산자 문제
	// Q1) 다음 코드의 출력문제를 예상해보기
	int num1 = 10, num2 = 20, num3 = 4;
	int num4 = 13, num5 = 4;

	printf("%d\n", num1 == num2);
	printf("%d\n", num4 != num1);
	printf("%d\n", num4 > num2);
	printf("%d\n", num5 >= num3);
	printf("%d\n", num1 < num4);
	printf("%d\n", num3 <= num1);
	*/

	/*
	// 논리연산자 문제
	Q1 ) 다음 ㅋ코드의 출력 내용을 예상해보기
	int num1 = 10, num2 = 20, num3 = 4;
	int num4 = 13, num5 = 4;

	printf("%d\n", num5 >= num3 || num1 == num2); //1
	printf("%d\n", num4 != num1 && num1 < num2); //1
	printf("%d\n", num4 > num2 && num3 == num5); //0
	printf("%d\n", !num5 > num3); // !4 => 0 => 0 > 4 => 0 
	printf("%d\n", !(num1 > num4) || num3 <= num1); //1
	*/

	/*
	//Q2) 다음 코드의 출력 내용을 예상
	int a = 1, b = 0, c = 12, d = 12;
	d = a++ || ++b * d-- / ++c; // 2 0 12 1 >> a가 후위 연산 - 1이므로 무조건 해당 값은 참 => 나머지 변동 없음
	printf("%d %d %d %d\n", a, b, c, d);

	d = b++ && ++a / ++c * d++; // 2 1 12 0 >> b가 후위 연산 - 0이므로 무조건 해당 값은 거짓 => 나머지 변동 없음
	printf("%d %d %d %d\n", a, b, c, d);
	*/

	return 0;
}